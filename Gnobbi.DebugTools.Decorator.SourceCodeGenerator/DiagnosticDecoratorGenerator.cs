using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Gnobbi.DebugTools.Decorator.SourceCodeGenerator
{
    [Generator]
    public class DiagnosticDecoratorSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new InterfaceReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is InterfaceReceiver receiver))
                return;

            receiver.SetContext(context);

            var compilation = context.Compilation;
            foreach (var ifaceDecl in receiver.CandidateInterfaces)
            {
                var model = compilation.GetSemanticModel(ifaceDecl.SyntaxTree);
                if (!(model.GetDeclaredSymbol(ifaceDecl) is INamedTypeSymbol ifaceSymbol))
                {
                    continue;
                }

                if (!receiver.IsAcceped(ifaceSymbol))
                {
                    continue;
                }

                GenerateCode(context, ifaceSymbol);
            }
        }

        private void GenerateCode(GeneratorExecutionContext context, INamedTypeSymbol ifaceSymbol)
        {
            var code = GenerateDecoratorForInterface(ifaceSymbol);
            var className = ifaceSymbol.Name.TrimStart('I') + "_DiagnosticDecorator";
            context.AddSource($"{className}_DiagnosticDecorator.g.cs", SourceText.From(code, Encoding.UTF8));
        }

        private string GenerateDecoratorForInterface(INamedTypeSymbol ifaceSymbol)
        {
            var nsSet = new HashSet<string>();
            nsSet.Add(ifaceSymbol.ContainingNamespace.ToDisplayString());
            foreach (var method in ifaceSymbol.GetMembers().OfType<IMethodSymbol>())
            {
                if (method.MethodKind != MethodKind.Ordinary)
                {
                    continue;
                }
                AddNamespacesFromType(method.ReturnType, nsSet);
                foreach (var param in method.Parameters)
                {
                    AddNamespacesFromType(param.Type, nsSet);
                }
            }
            nsSet.Remove("<global namespace>");
            var className = ifaceSymbol.Name.TrimStart('I') + "_DiagnosticDecorator";
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");

            // Namespaces
            foreach (var ns in nsSet)
                sb.AppendLine($"using {ns};");

            sb.AppendLine();
            sb.AppendLine("namespace Gnobbi.DebugTools.Decorator");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {className} : {ifaceSymbol.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        private readonly {ifaceSymbol.Name} _inner;");
            sb.AppendLine("        private readonly IDiagnosticEntryHandler _handler;");
            sb.AppendLine();
            sb.AppendLine($"        public {className}({ifaceSymbol.Name} inner, IDiagnosticEntryHandler handler)");
            sb.AppendLine("        {");
            sb.AppendLine("            _inner = inner;");
            sb.AppendLine("            _handler = handler;");
            sb.AppendLine("        }");

            // Methoden generieren
            foreach (var method in ifaceSymbol.GetMembers().OfType<IMethodSymbol>())
            {
                if (method.MethodKind != MethodKind.Ordinary)
                    continue;

                GenerateMethod(method, sb, ifaceSymbol.Name);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private void AddNamespacesFromType(ITypeSymbol type, HashSet<string> namespaces)
        {
            if (type == null || type.Kind == SymbolKind.ErrorType)
                return;

            if (type is INamedTypeSymbol named)
            {
                if (!string.IsNullOrEmpty(named.ContainingNamespace?.ToString()))
                    namespaces.Add(named.ContainingNamespace.ToString());

                // Rekursiv für generische Typen (z. B. Result<Project>)
                foreach (var typeArg in named.TypeArguments)
                    AddNamespacesFromType(typeArg, namespaces);

                // Tuple-Elemente
                if (named.IsTupleType)
                {
                    foreach (var element in named.TupleElements)
                        AddNamespacesFromType(element.Type, namespaces);
                }
            }
            else if (type is IArrayTypeSymbol array)
            {
                AddNamespacesFromType(array.ElementType, namespaces);
            }
            else if (type is IPointerTypeSymbol ptr)
            {
                AddNamespacesFromType(ptr.PointedAtType, namespaces);
            }
        }


        private void GenerateMethod(IMethodSymbol method, StringBuilder sb, string interfaceName)
        {
            var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            var isAsync = method.ReturnType.Name == "Task" || method.ReturnType.OriginalDefinition.Name == "Task";

            var methodName = method.Name;
            string GetCorrectRefType(IParameterSymbol p)
            {
                switch (p.RefKind)
                {
                    case RefKind.None: return "";
                    case RefKind.Ref: return "ref ";
                    case RefKind.Out: return "out ";
                    default: throw new NotSupportedException($"Unsupported RefKind: {p.RefKind}");
                }
                ;
            }
            var paramterWithTypes = string.Join(", ", method.Parameters.Select(p => $"{GetCorrectRefType(p)}{p.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)} {p.Name}"));
            var paramNamesForCalling = string.Join(", ", method.Parameters.Select(p => $"{GetCorrectRefType(p)}{p.Name}"));

            // Diagnostic Entity Name
            var fullMethodName = (
                method.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) +
                 "__"
                 + methodName
                 + "__"
                 + string.Join("_", method.Parameters.Select(p => p.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat))))
                .MakeValidName();
            var entityName = fullMethodName + "_DiagnosticEntiy";

            // Methode
            sb.AppendLine();
            sb.AppendLine($"        public {(isAsync ? "async ": " ")}{returnType} {methodName}({paramterWithTypes})");
            sb.AppendLine("        {");
            sb.AppendLine($"            var _GeneratedDI_startedAt = DateTime.UtcNow;");
            if (returnType == "void" || returnType == "Task")
            {
                sb.AppendLine($"            {(isAsync ? "await " : " ")}_inner.{methodName}({paramNamesForCalling});");
            }
            else
            {
                sb.AppendLine($"            var result = {(isAsync ? "await " : " ")}_inner.{methodName}({paramNamesForCalling});");

            }
            sb.AppendLine($"            var diagnosticEntity = new {entityName}");
            sb.AppendLine("            {");
            foreach (var p in method.Parameters)
            {
                sb.AppendLine($"                Input_{p.Name} = {p.Name},");
            }
            sb.AppendLine($"                ProcessId = Environment.ProcessId,");
            sb.AppendLine($"                ThreadId = System.Threading.Thread.CurrentThread.ManagedThreadId,");
            sb.AppendLine($"                MethodName = \"{returnType} {methodName}({paramterWithTypes})\",");
            sb.AppendLine($"                ClassName = \"{interfaceName}\",");
            sb.AppendLine($"                StartedAt = _GeneratedDI_startedAt,");
            if (returnType == "Task" || returnType == "void")
            {

            }
            else
            {
                sb.AppendLine($"                Result = result,");
            }

            sb.AppendLine("                FinshedAt = DateTime.UtcNow");
            sb.AppendLine("            };");
            sb.AppendLine();

            sb.AppendLine("            diagnosticEntity.ElapsedMilliseconds = (int)(diagnosticEntity.FinshedAt - diagnosticEntity.StartedAt).TotalMilliseconds;");
            // Aufruf inner
            sb.AppendLine();

            if (isAsync)
            {
                sb.AppendLine("            await _handler.HandleDiagnosticEntryAsync(diagnosticEntity);");
            }
            else
            {
                sb.AppendLine("            _handler.HandleDiagnosticEntryAsync(diagnosticEntity).GetAwaiter().GetResult();");
            }

            if (returnType == "Task" || returnType == "void")
            {
                sb.AppendLine("            return;");
            }
            else
            {
                sb.AppendLine("            return result;");
            }
            sb.AppendLine("        }");

            // Diagnostic Entity Klasse
            sb.AppendLine();
            sb.AppendLine($"        private class {entityName} : DiagnosticEntiyBase");
            sb.AppendLine("        {");
            foreach (var p in method.Parameters)
                sb.AppendLine($"            public {p.Type} Input_{p.Name} {{ get; set; }}");

            if (returnType == "Task" || returnType == "void")
            {

            }
            else if (isAsync && method.ReturnType is INamedTypeSymbol ts2 && ts2.TypeArguments.Length == 1)
            {
                sb.AppendLine($"            public {ts2.TypeArguments[0]} Result {{ get; set; }}");
            }
            else
            {
                sb.AppendLine($"            public {method.ReturnType} Result {{ get; set; }}");
            }
            sb.AppendLine("        }");
        }
    }


    public static class CSharpNameSanitizer
    {
        public static string MakeValidName(this string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return "_";

            var sb = new StringBuilder();

            // Erste Zeichen: Buchstabe oder Unterstrich
            char firstChar = input[0];
            if (IsValidIdentifierStartChar(firstChar))
                sb.Append(firstChar);
            else
                sb.Append('_');

            // Restliche Zeichen
            for (int i = 1; i < input.Length; i++)
            {
                char c = input[i];
                sb.Append(IsValidIdentifierPartChar(c) ? c : '_');
            }

            return sb.ToString();
        }

        private static bool IsValidIdentifierStartChar(char c)
        {
            return char.IsLetter(c) || c == '_';
        }

        private static bool IsValidIdentifierPartChar(char c)
        {
            return char.IsLetterOrDigit(c) || c == '_';
        }
    }
}
